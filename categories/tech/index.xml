<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech on Electronic-Waste的博客</title><link>https://blog.electronicwaste.cn/categories/tech/</link><description>Recent content in Tech on Electronic-Waste的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 26 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.electronicwaste.cn/categories/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Structured Log</title><link>https://blog.electronicwaste.cn/p/structured-log/</link><pubDate>Tue, 26 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.electronicwaste.cn/p/structured-log/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>日志作为一种帮助开发者快速定位问题的工具，在各个开源项目以及实际生产环境中都被广泛使用，其重要性不言而喻。但是，开发者往往是懒惰的，在开发的过程中为了图省事，经常不写log（比如说我），或者写的log极其粗糙（诸如&lt;code>fmt.Println(&amp;quot;OK&amp;quot;)&lt;/code>之流&amp;hellip;）。一旦程序出现了问题，根据现有的日志往往不能很好地定位到错误所在的地方，得花更多的时间打更多log（更是依托答辩）去找bug。&lt;/p>
&lt;p>痛定思痛，我打算来学习Log的Best Practice，让我之后debug不要再那么痛苦，写的日志不要再那么答辩🤡&lt;/p>
&lt;p>于是就有了本章&lt;strong>Structured Log&lt;/strong>！&lt;/p>
&lt;h2 id="什么是structured-log">什么是Structured Log&lt;/h2>
&lt;p>意思是&lt;strong>结构化的日志&lt;/strong>，我觉得主要有以下特性：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>日志格式&lt;/strong>：从基于键-值（像syslog）到非常结构化和详细（像JSON）。数据越结构化——每行日志就越大，尽管更易于查询和包含更丰富的信息。&lt;/li>
&lt;li>&lt;strong>等级日志（或日志等级）&lt;/strong>：不同等级对应着不同重要性的日志。可见性可限制单个等级，仅限于某些重要性或等级以上的日志（如：仅记录WARN和更高等级）。通常日志等级在生产环境中是静态的，查找DEBUG等级的日志通常需要重新部署。&lt;/li>
&lt;li>&lt;strong>因果顺序&lt;/strong>：保存写入的实际时间&lt;/li>
&lt;li>&lt;strong>日志关联&lt;/strong>：能看到与特定请求或特定事件相关的所有日志，帮助我们深入到特定请求的相关信息中&lt;/li>
&lt;/ul>
&lt;h2 id="logrus">Logrus&lt;/h2>
&lt;p>Logrus是一个常用的日志库，有各种丰富的特性&lt;/p>
&lt;h3 id="支持不同的日志等级">支持不同的日志等级&lt;/h3>
&lt;p>Trace、Debug、Info、Warning、Error、Fatal、Panic&lt;/p>
&lt;p>日志等级依次上升，可以通过SetLevel函数设置日志等级，比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">logrus&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetLevel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">InfoLevel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样子只有Info等级及以上的日志会被打印&lt;/p>
&lt;h3 id="可扩展的hook机制">可扩展的Hook机制&lt;/h3>
&lt;p>允许使用者通过Hook的方式将日志分发到任意地方，如`本地日志文件，logstash，elasticsearch或者mq等，或者通过Hook定义日志内容和格式&lt;/p>
&lt;h3 id="可选的日志输出格式">可选的日志输出格式&lt;/h3>
&lt;p>内置了两种日志格式JSONFormater和TextFormater，还可以自定义日志格式&lt;/p>
&lt;h3 id="filed机制">Filed机制&lt;/h3>
&lt;p>可以通过Field机制进行结构化的日志记录，通常将一些字段始终加入到日志语句中会很有帮助&lt;/p>
&lt;p>相比于&lt;code>log.Fatalf(&amp;quot;Failed to send event %s to topic&amp;quot;, event, topic)&lt;/code>&lt;/p>
&lt;p>使用如下的日志更加合适：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WithFields&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Fields&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;event&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">event&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;topic&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">topic&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}).&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Failed to send event.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>除了&lt;code>WithField&lt;/code>和&lt;code>WithFields&lt;/code>添加的字段以外，一些字段会自动添加到所有日记记录中：&lt;/p>
&lt;ol>
&lt;li>time：记录日志的时间戳&lt;/li>
&lt;li>msg：记录的日志信息&lt;/li>
&lt;li>level：记录的日志级别&lt;/li>
&lt;/ol>
&lt;h3 id="线程安全机制">线程安全机制&lt;/h3>
&lt;p>默认的logger在并发写的时候是受mutex保护的，也就是说是线程安全的&lt;/p></description></item></channel></rss>